# Требования к частям системы (Subsystem Requirements)

## 1. Мобильный клиент iOS (SwiftUI) — `src/app/mad_application`

### 1.1. Presentation слой (UI/UX)

- UI‑1: Навигация должна быть предсказуемой (Tab/Stack), глубина сценариев ограничена.
- UI‑2: Основные экраны должны поддерживать состояние: loading/empty/content/error.
- UI‑3: Для ошибок сети — отдельное «человеческое» сообщение и действие (Retry).
- UI‑4: Доступность: VoiceOver labels для интерактивных элементов, Dynamic Type, контраст.

### 1.2. Domain слой (Use Cases)

- D‑1: Все бизнес‑операции должны быть оформлены как use‑cases с явными входами/выходами.
- D‑2: Должны быть определены доменные модели без зависимости от UI/Network.
- D‑3: Ошибки должны быть типизированы (network/auth/validation/unknown) для UX‑обработки.

### 1.3. Data слой (Repositories)

- R‑1: Репозитории должны скрывать источник данных (remote/local/cache).
- R‑2: Репозиторий должен обеспечивать политику кэша (stale‑while‑revalidate или explicit refresh).
- R‑3: Должна быть стратегия ретраев и таймаутов для сетевых запросов.

### 1.4. Networking

- N‑1: Все запросы выполняются через единый клиент (URLSession), с логированием без PII.
- N‑2: Поддерживаются стандартные коды ошибок (401/403/404/429/5xx) и маппинг в доменные ошибки.
- N‑3: Конфигурация окружений (dev/stage/prod) задается через build settings или конфиг.

### 1.5. Persistence (локальные данные)

- P‑1: Токены/секреты — только Keychain.
- P‑2: Кэш данных — в CoreData/SQLite/FileCache (выбрать), с ограничением размера и TTL.
- P‑3: При очистке данных (logout) локальный кэш пользователя должен быть удален.

### 1.6. Observability в клиенте

- O‑1: Клиент должен отправлять crash‑события в выбранный инструмент (Crashlytics/Sentry).
- O‑2: Клиент должен логировать ключевые события UX (начало/успех/ошибка сценария) в аналитику.
- O‑3: Клиент должен измерять время: старт приложения, загрузка экрана/списка (включая network).

### 1.7. Обратная связь в клиенте

- F‑1: Кнопка «Обратная связь» доступна из Settings/Help.
- F‑2: Периодический NPS/CSI prompt показывается после завершения ключевого use‑case (rate‑limit).
- F‑3: Пользователь может приложить комментарий и (опционально) скриншот/логи без PII.

## 2. Backend API (Gateway/монолит или микросервисы)

### 2.1. API Gateway / BFF

- BFF‑1: Единая точка входа для мобильного клиента; включает auth middleware.
- BFF‑2: Rate limiting и защита от злоупотреблений (429).
- BFF‑3: Логирование запросов и корреляция (request_id/trace_id).

### 2.2. Auth service

- AUTH‑1: Выдача/обновление токенов (OAuth2/OIDC или custom) + отзыв сессий.
- AUTH‑2: Хранение паролей — только безопасные хэши (если email/password).
- AUTH‑3: Поддержка device/session management (по необходимости).

### 2.3. Core service (предметная область X)

- CORE‑1: CRUD операций с доменными сущностями; валидация входных данных.
- CORE‑2: Идемпотентность для операций, где возможно повторение (ретраи клиента).
- CORE‑3: Версионирование API (например `/v1`).

### 2.4. Data storage

- DB‑1: Транзакционное хранилище (PostgreSQL или аналог) для core данных.
- DB‑2: Миграции схемы версионируются.
- DB‑3: Резервное копирование (если разворачивается отдельно) и политика retention.

## 3. Система качества (Observability/Monitoring)

### 3.1. Метрики и мониторинг

- MON‑1: Backend должен экспортировать метрики в Prometheus (latency, RPS, error rate).
- MON‑2: Дашборды Grafana должны покрывать SLI/SLO (аптайм, p95 latency, error budget).
- MON‑3: Альтернатива/дополнение: Zabbix для инфраструктуры (CPU/RAM/диск/сеть).

### 3.2. Логи и трассировки

- LOG‑1: Централизованный сбор логов (например, Loki/ELK) с корреляцией по trace_id.
- TRACE‑1: Распределенные трассы (OpenTelemetry) для выявления узких мест.

## 4. Аналитика продукта

- ANA‑1: События фиксируются с версией приложения, платформой, экраном, исходом (success/fail).
- ANA‑2: Не хранить PII без необходимости; обеспечить согласие пользователя при сборе.
- ANA‑3: Метрики ретеншна/конверсии/времени сессии доступны в отчете.

## 5. Сервис обратной связи

- FB‑1: Прием NPS/CSI ответов и текстовых сообщений.
- FB‑2: Хранение связки: версия приложения, устройство, OS, сценарий, timestamp.
- FB‑3: Маршрутизация в issue tracker (опционально) и SLA обработки.

